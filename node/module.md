#node module

노드에서는 모듈을 통해 전역 네임스페이스를 쉽게 오염시킬 수 있는 방식을 사용하지 않는다. 인클루드한 파일 중 어떤 변수와 함수를 애플리케이션에서 사용할 것인지 선택할 수 있다.
* 만약 하나 이상의 변수나 함수를 반환한다면 `exports` 
* 그렇지 않고 모듈이 하나의 변수나 함수만을 반환한다면 `module.exports`

> 이유는 애플리케이션에 최종적으로 내보내지는 것은 module.exports 다. exports는 초기 단계에서 속성을 추가할 수 있는 빈 객체인 module.exports의 전역 참조 역할을 하고 있을 뿐이다. 그래서 exports.myFunc는 module.exports.myFunc의 줄임말이다. 결과적으로 exports 에 다른 값이 할당되면 이는 module.exports와 exports 사이의 참조가 깨지는 것을 의미한다. 그렇기 때문에 exports = myFunc 는 잘못된 방법이고 생각하는대로 동작되지 않을 것이다.

###require와 동기식 I/O에 관해
require는 노드에서 사용하는 몇 안되는 동기식 I/O이다. 그렇기 때문에 I/O가 많이 발생하는 부분에서 require를 사용하게 되면 해당 호출이 완료될 때까지 노드가 어떠한 작업도 하지 못하게 한다. 이러한 이유로 require를 비롯한 다른 동기식 작업을 애플리케이션 초기화 단계에서만 사용한다.

### require 경로가 생략되었을때 동작 로직

    var currency = require('currency');
	
1. 우선 노드의 기본 모듈인지 확인하고 기본 모듈일시에 반환
2. 현재 디렉토리에 node_module 이 있는지 확인
3. 없을시에 부모 디렉토리가 있는지 확인하여 2번 동작 반복
4. 최종 부모 디렉토리까지 없을시에 node_module 환경 변수에 명시된 디렉토리에 있는지 확인하여 없을시에 예외 발생

모듈 디렉토리를 발견하였을 경우 package.json 파일이 없으면 index.js를 가장 먼저 확인한다. index 가 아닌 파일을 사용하려면 package.json에 main을 키로 선언을 해줘야 한다.

	{
    	"main": "./currency"
    }
    
이 때 노드는 모듈을 객체 형식으로 캐시한다. 만약 두 파일에서 같은 모듈을 이용하는 경우 첫 번째 호출 시 모듈을 애플리케이션의 메모리 영역에 저장한다. 따라서 두 번재 호출부터 모듈의 소스파일에 접근하는 과정이 필요 없다. 또 한 두 번째 호출부터는 캐시된 데이터를 직접 제어할수 있는데, 이러한 특성은 개발자가 새로운 버전의 모듈을 만들 필요 없이 수정하여 동작하도록 구성할 수 있다.